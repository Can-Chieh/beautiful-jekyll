---
layout: post
published: ture
title: LeetCode
comments: false
show-avatar: false
tag: ["LeetCode", "C"]
---

#### 141. Linked List Cycle
http://leetcode.com/problems/linked-list-cycle/description/

Given a linked list, determine if it has a cycle in it.  
Follow up:  
Can you solve it without using extra space?


類似龜兔賽跑的概念，跑道有兩種有cycle跟沒有cycle，如果有cycle，則在龜兔都進入cycle時，兔子與烏龜會因為速度的不同，最終在同一點相遇，
假設烏龜速度為1，兔子為2，當兩者都進入cycle中，兩者的速度差為1，可以想成烏龜靜止不動的速度為0，而兔子速度為1，
兩者的距離就會隨時間而變短，最終相遇。
反之沒有cycle，兔子就會先跑到終點，結束比賽。  
以下用兩個pointer來表示，兔子為`fast`一次跳兩格，烏龜為`slow`一次走一格。
這個解法有個名稱叫Floyd Cycle Detection Algorithm

時間複雜度：O(n)
空間複雜度：O(1)

使用C語言來解題

```C
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
 
bool hasCycle(struct ListNode *head) {
    if ( head == NULL || head->next == NULL) {
        return false;
    }
    struct ListNode* fast = head->next;
    struct ListNode* slow = head;
    
    while( fast != slow) {
        if( fast == NULL || fast->next == NULL) {
            return false;  // 兔子抵達終點
        }      
        fast = fast->next->next;
        slow = slow->next;
    }
    
    return true;  // 龜兔相遇
}

```



